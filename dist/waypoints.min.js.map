{"version":3,"sources":["webpack:///waypoints.min.js","webpack:///webpack/bootstrap a5ac1ede704baa28b3ff","webpack:///./source/index.js","webpack:///./source/dom.js","webpack:///./source/context.js","webpack:///./source/group.js","webpack:///./source/waypoint.js"],"names":["modules","__webpack_require__","moduleId","installedModules","exports","module","id","loaded","call","m","c","p","DOM","Context","Group","Waypoint","oldWindowLoad","window","onload","findOrCreateByElement","refreshAll","_classCallCheck","instance","Constructor","TypeError","_slicedToArray","sliceIterator","arr","i","_arr","_n","_d","_e","undefined","_s","_i","Symbol","iterator","next","done","push","value","length","err","Array","isArray","Object","_createClass","defineProperties","target","props","descriptor","enumerable","configurable","writable","defineProperty","key","protoProps","staticProps","prototype","element","this","handlers","isWindow","ownerDocument","defaultView","innerHeight","docElement","clientHeight","innerWidth","clientWidth","includeMargin","height","computedStyle","getComputedStyle","parseInt","marginTop","marginBottom","width","marginLeft","marginRight","event","handler","_event$split","split","_event$split2","eventType","_event$split2$","namespace","nsHandlers","nsTypeList","addEventListener","_event$split3","_event$split4","removeListeners","ns","type","listeners","_this","forEach","listener","removeEventListener","documentElement","rect","getBoundingClientRect","top","pageYOffset","clientTop","left","pageXOffset","clientLeft","document","isEmptyObject","obj","requestAnimationFrameShim","callback","setTimeout","keyCounter","contexts","reqAnimationFrame","requestAnimationFrame","mozRequestAnimationFrame","webkitRequestAnimationFrame","oRequestAnimationFrame","bind","dom","didScroll","didResize","oldScroll","x","scrollLeft","y","scrollTop","waypoints","vertical","horizontal","waypointContextKey","createThrottledScrollHandler","createThrottledResizeHandler","scrollHandler","handleScroll","on","_this2","resizeHandler","handleResize","triggeredGroups","axes","newScroll","axisKey","axis","waypointKey","waypoint","direction","shouldScrollTrigger","group","queueTrigger","groupKey","flushTriggers","refresh","horizontalEmpty","verticalEmpty","off","destroy","contextOffset","offset","contextScroll","contextDimension","refreshTriggerPoint","contextAdjustment","findByElement","contextId","byTriggerPoint","a","b","triggerPoint","byReverseTriggerPoint","groups","_ref","name","clearTriggerQueues","index","indexOf","splice","triggerQueues","up","down","right","_loop","reverse","sort","continuous","trigger","Adapter","inArray","options","_extends","assign","arguments","source","hasOwnProperty","allWaypoints","axialDirections","backward","forward","Error","mergeOptions","enabled","findOrCreate","context","add","offsetAliases","defaults","remove","previous","wasBeforeTriggerPoint","nowAfterTriggerPoint","axialDirection","elementOffset","adjustment","oldTriggerPoint","offsetProp","apply","parseFloat","Math","ceil","floor","shouldRefreshTrigger","scrollProp","wasBeforeScroll","nowAfterScroll","triggeredBackward","triggeredForward","freshWaypoint","method","invokeAll","get","bottom-in-view","outerHeight","right-in-view","outerWidth"],"mappings":"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","file":"waypoints.min.js","sourcesContent":["/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar DOM = __webpack_require__(1);\n\tvar Context = __webpack_require__(2)(DOM);\n\tvar Group = __webpack_require__(3)();\n\tvar Waypoint = __webpack_require__(4)(DOM, Context, Group);\n\tvar oldWindowLoad = window.onload;\n\t\n\tContext.findOrCreateByElement(window);\n\t\n\twindow.onload = function () {\n\t  if (oldWindowLoad) {\n\t    oldWindowLoad();\n\t  }\n\t  Context.refreshAll();\n\t};\n\t\n\twindow.Waypoint = Waypoint;\n\tmodule.exports = Waypoint;\n\n/***/ },\n/* 1 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tmodule.exports = function () {\n\t  function DOM(element) {\n\t    _classCallCheck(this, DOM);\n\t\n\t    this.element = element;\n\t    this.handlers = {};\n\t    this.isWindow = element.window === element;\n\t    this.window = this.isWindow ? element : element.ownerDocument.defaultView;\n\t  }\n\t\n\t  _createClass(DOM, [{\n\t    key: 'innerHeight',\n\t    value: function innerHeight() {\n\t      if (this.isWindow) {\n\t        return this.innerHeight || this.docElement.clientHeight;\n\t      }\n\t      return this.element.clientHeight;\n\t    }\n\t  }, {\n\t    key: 'innerWidth',\n\t    value: function innerWidth() {\n\t      if (this.isWindow) {\n\t        return this.innerWidth;\n\t      }\n\t      return this.element.clientWidth;\n\t    }\n\t  }, {\n\t    key: 'outerHeight',\n\t    value: function outerHeight(includeMargin) {\n\t      var height = this.innerHeight();\n\t\n\t      if (includeMargin && !this.isWindow) {\n\t        var computedStyle = window.getComputedStyle(this.element);\n\t        height += parseInt(computedStyle.marginTop, 10);\n\t        height += parseInt(computedStyle.marginBottom, 10);\n\t      }\n\t\n\t      return height;\n\t    }\n\t  }, {\n\t    key: 'outerWidth',\n\t    value: function outerWidth(includeMargin) {\n\t      var width = this.innerWidth();\n\t\n\t      if (includeMargin && !this.isWindow) {\n\t        var computedStyle = window.getComputedStyle(this.element);\n\t        width += parseInt(computedStyle.marginLeft, 10);\n\t        width += parseInt(computedStyle.marginRight, 10);\n\t      }\n\t\n\t      return width;\n\t    }\n\t  }, {\n\t    key: 'scrollLeft',\n\t    value: function scrollLeft() {\n\t      return this.element[this.isWindow ? 'pageXOffset' : 'scrollLeft'];\n\t    }\n\t  }, {\n\t    key: 'scrollTop',\n\t    value: function scrollTop() {\n\t      return this.element[this.isWindow ? 'pageYOffset' : 'scrollTop'];\n\t    }\n\t  }, {\n\t    key: 'on',\n\t    value: function on(event, handler) {\n\t      var _event$split = event.split('.'),\n\t          _event$split2 = _slicedToArray(_event$split, 2),\n\t          eventType = _event$split2[0],\n\t          _event$split2$ = _event$split2[1],\n\t          namespace = _event$split2$ === undefined ? '__default' : _event$split2$;\n\t\n\t      var nsHandlers = this.handlers[namespace] = this.handlers[namespace] || {};\n\t      var nsTypeList = nsHandlers[eventType] = nsHandlers[eventType] || [];\n\t\n\t      nsTypeList.push(handler);\n\t      this.element.addEventListener(eventType, handler);\n\t    }\n\t  }, {\n\t    key: 'off',\n\t    value: function off(event, handler) {\n\t      var _event$split3 = event.split('.'),\n\t          _event$split4 = _slicedToArray(_event$split3, 2),\n\t          eventType = _event$split4[0],\n\t          namespace = _event$split4[1];\n\t\n\t      if (namespace && this.handlers[namespace] && eventType) {\n\t        this.removeListeners(this.handlers[namespace][eventType], handler);\n\t        this.handlers[namespace][eventType] = [];\n\t      } else if (eventType) {\n\t        for (var ns in this.handlers) {\n\t          this.removeListeners(this.handlers[ns][eventType] || [], handler);\n\t          this.handlers[ns][eventType] = [];\n\t        }\n\t      } else if (namespace && this.handlers[namespace]) {\n\t        for (var type in this.handlers[namespace]) {\n\t          this.removeListeners(this.handlers[namespace][type], handler);\n\t        }\n\t        this.handlers[namespace] = {};\n\t      }\n\t    }\n\t  }, {\n\t    key: 'removeListeners',\n\t    value: function removeListeners(listeners, handler) {\n\t      var _this = this;\n\t\n\t      listeners.forEach(function (listener) {\n\t        if (!handler || handler === listener) {\n\t          _this.element.removeEventListener(listener);\n\t        }\n\t      });\n\t    }\n\t\n\t    /* Adapted from jQuery 1.x offset() */\n\t\n\t  }, {\n\t    key: 'offset',\n\t    value: function offset() {\n\t      if (!this.element.ownerDocument) {\n\t        return null;\n\t      }\n\t\n\t      var documentElement = this.element.ownerDocument.documentElement;\n\t      var rect = this.element.getBoundingClientRect();\n\t\n\t      return {\n\t        top: rect.top + this.window.pageYOffset - documentElement.clientTop,\n\t        left: rect.left + this.window.pageXOffset - documentElement.clientLeft\n\t      };\n\t    }\n\t  }], [{\n\t    key: 'viewportHeight',\n\t    value: function viewportHeight() {\n\t      return window.innerHeight || document.documentElement.clientHeight;\n\t    }\n\t  }, {\n\t    key: 'viewportWidth',\n\t    value: function viewportWidth() {\n\t      return document.documentElement.clientWidth;\n\t    }\n\t  }]);\n\t\n\t  return DOM;\n\t}();\n\n/***/ },\n/* 2 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tfunction isEmptyObject(obj) {\n\t  for (var key in obj) {\n\t    return false;\n\t  }\n\t  return true;\n\t}\n\t\n\tmodule.exports = function (DOM) {\n\t  var keyCounter = 0;\n\t  var contexts = {};\n\t  var reqAnimationFrame = (window.requestAnimationFrame || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame || window.oRequestAnimationFrame || requestAnimationFrameShim).bind(window);\n\t\n\t  function requestAnimationFrameShim(callback) {\n\t    window.setTimeout(callback, 1000 / 60);\n\t  }\n\t\n\t  return function () {\n\t    function Context(element) {\n\t      _classCallCheck(this, Context);\n\t\n\t      this.element = element;\n\t      this.dom = new DOM(element);\n\t      this.key = 'context-' + keyCounter;\n\t      this.didScroll = false;\n\t      this.didResize = false;\n\t      this.oldScroll = {\n\t        x: this.dom.scrollLeft(),\n\t        y: this.dom.scrollTop()\n\t      };\n\t      this.waypoints = {\n\t        vertical: {},\n\t        horizontal: {}\n\t      };\n\t\n\t      element.waypointContextKey = this.key;\n\t      contexts[element.waypointContextKey] = this;\n\t      keyCounter += 1;\n\t\n\t      this.createThrottledScrollHandler();\n\t      if (this.dom.isWindow) {\n\t        this.createThrottledResizeHandler();\n\t      }\n\t    }\n\t\n\t    _createClass(Context, [{\n\t      key: 'createThrottledScrollHandler',\n\t      value: function createThrottledScrollHandler() {\n\t        var _this = this;\n\t\n\t        var scrollHandler = function scrollHandler() {\n\t          _this.handleScroll();\n\t          _this.didScroll = false;\n\t        };\n\t\n\t        this.dom.on('scroll.waypoints', function () {\n\t          if (!_this.didScroll) {\n\t            _this.didScroll = true;\n\t            reqAnimationFrame(scrollHandler);\n\t          }\n\t        });\n\t      }\n\t    }, {\n\t      key: 'createThrottledResizeHandler',\n\t      value: function createThrottledResizeHandler() {\n\t        var _this2 = this;\n\t\n\t        var resizeHandler = function resizeHandler() {\n\t          _this2.handleResize();\n\t          _this2.didResize = false;\n\t        };\n\t\n\t        this.dom.on('resize.waypoints', function () {\n\t          if (!_this2.didResize) {\n\t            _this2.didResize = true;\n\t            reqAnimationFrame(resizeHandler);\n\t          }\n\t        });\n\t      }\n\t    }, {\n\t      key: 'handleResize',\n\t      value: function handleResize() {\n\t        Context.refreshAll();\n\t      }\n\t    }, {\n\t      key: 'handleScroll',\n\t      value: function handleScroll() {\n\t        var triggeredGroups = {};\n\t        var axes = {\n\t          horizontal: {\n\t            newScroll: this.dom.scrollLeft(),\n\t            oldScroll: this.oldScroll.x\n\t          },\n\t          vertical: {\n\t            newScroll: this.dom.scrollTop(),\n\t            oldScroll: this.oldScroll.y\n\t          }\n\t        };\n\t\n\t        for (var axisKey in axes) {\n\t          var axis = axes[axisKey];\n\t\n\t          for (var waypointKey in this.waypoints[axisKey]) {\n\t            var waypoint = this.waypoints[axisKey][waypointKey];\n\t            var direction = waypoint.shouldScrollTrigger(axis.oldScroll, axis.newScroll);\n\t            if (direction) {\n\t              waypoint.group.queueTrigger(waypoint, direction);\n\t              triggeredGroups[waypoint.group.id] = waypoint.group;\n\t            }\n\t          }\n\t        }\n\t\n\t        for (var groupKey in triggeredGroups) {\n\t          triggeredGroups[groupKey].flushTriggers();\n\t        }\n\t\n\t        this.oldScroll = {\n\t          x: axes.horizontal.newScroll,\n\t          y: axes.vertical.newScroll\n\t        };\n\t      }\n\t    }, {\n\t      key: 'add',\n\t      value: function add(waypoint) {\n\t        this.waypoints[waypoint.axis][waypoint.key] = waypoint;\n\t        this.refresh();\n\t      }\n\t    }, {\n\t      key: 'remove',\n\t      value: function remove(waypoint) {\n\t        var horizontalEmpty = isEmptyObject(this.waypoints.horizontal);\n\t        var verticalEmpty = isEmptyObject(this.waypoints.vertical);\n\t\n\t        delete this.waypoints[waypoint.axis][waypoint.key];\n\t        if (horizontalEmpty && verticalEmpty && !this.dom.isWindow) {\n\t          this.dom.off('.waypoints');\n\t          delete contexts[this.key];\n\t        }\n\t      }\n\t    }, {\n\t      key: 'destroy',\n\t      value: function destroy() {\n\t        for (var axis in this.waypoints) {\n\t          for (var waypointKey in this.waypoints[axis]) {\n\t            this.waypoints[axis][waypointKey].destroy();\n\t          }\n\t        }\n\t      }\n\t    }, {\n\t      key: 'refresh',\n\t      value: function refresh() {\n\t        this.handleScroll();\n\t\n\t        var contextOffset = this.dom.offset() || { left: 0, top: 0 };\n\t        var triggeredGroups = {};\n\t        var axes = {\n\t          horizontal: {\n\t            contextOffset: contextOffset.left,\n\t            contextScroll: this.dom.isWindow ? 0 : this.oldScroll.x,\n\t            contextDimension: this.dom.innerWidth()\n\t          },\n\t          vertical: {\n\t            contextOffset: contextOffset.top,\n\t            contextScroll: this.dom.isWindow ? 0 : this.oldScroll.y,\n\t            contextDimension: this.dom.innerHeight()\n\t          }\n\t        };\n\t\n\t        for (var axisKey in axes) {\n\t          var axis = axes[axisKey];\n\t          for (var waypointKey in this.waypoints[axisKey]) {\n\t            var waypoint = this.waypoints[axisKey][waypointKey];\n\t            var direction = waypoint.refreshTriggerPoint({\n\t              contextDimension: axis.contextDimension,\n\t              contextAdjustment: axis.contextScroll - axis.contextOffset\n\t            });\n\t\n\t            if (direction) {\n\t              waypoint.group.queueTrigger(waypoint, direction);\n\t              triggeredGroups[waypoint.group.id] = waypoint.group;\n\t            }\n\t          }\n\t        }\n\t\n\t        reqAnimationFrame(function () {\n\t          for (var groupKey in triggeredGroups) {\n\t            triggeredGroups[groupKey].flushTriggers();\n\t          }\n\t        });\n\t\n\t        return this;\n\t      }\n\t    }], [{\n\t      key: 'findOrCreateByElement',\n\t      value: function findOrCreateByElement(element) {\n\t        return Context.findByElement(element) || new Context(element);\n\t      }\n\t    }, {\n\t      key: 'findByElement',\n\t      value: function findByElement(element) {\n\t        return contexts[element.waypointContextKey];\n\t      }\n\t    }, {\n\t      key: 'refreshAll',\n\t      value: function refreshAll() {\n\t        for (var contextId in contexts) {\n\t          contexts[contextId].refresh();\n\t        }\n\t      }\n\t    }]);\n\t\n\t    return Context;\n\t  }();\n\t};\n\n/***/ },\n/* 3 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tmodule.exports = function () {\n\t  function byTriggerPoint(a, b) {\n\t    return a.triggerPoint - b.triggerPoint;\n\t  }\n\t\n\t  function byReverseTriggerPoint(a, b) {\n\t    return b.triggerPoint - a.triggerPoint;\n\t  }\n\t\n\t  var groups = {\n\t    vertical: {},\n\t    horizontal: {}\n\t  };\n\t\n\t  return function () {\n\t    function Group(_ref) {\n\t      var axis = _ref.axis,\n\t          name = _ref.name;\n\t\n\t      _classCallCheck(this, Group);\n\t\n\t      this.name = name;\n\t      this.axis = axis;\n\t      this.id = name + '-' + axis;\n\t      this.waypoints = [];\n\t      this.clearTriggerQueues();\n\t      groups[axis][name] = this;\n\t    }\n\t\n\t    _createClass(Group, [{\n\t      key: 'add',\n\t      value: function add(waypoint) {\n\t        this.waypoints.push(waypoint);\n\t      }\n\t    }, {\n\t      key: 'remove',\n\t      value: function remove(waypoint) {\n\t        var index = this.waypoints.indexOf(waypoint);\n\t        if (index > -1) {\n\t          this.waypoints.splice(index, 1);\n\t        }\n\t      }\n\t    }, {\n\t      key: 'clearTriggerQueues',\n\t      value: function clearTriggerQueues() {\n\t        this.triggerQueues = {\n\t          up: [],\n\t          down: [],\n\t          left: [],\n\t          right: []\n\t        };\n\t      }\n\t    }, {\n\t      key: 'queueTrigger',\n\t      value: function queueTrigger(waypoint, direction) {\n\t        this.triggerQueues[direction].push(waypoint);\n\t      }\n\t    }, {\n\t      key: 'flushTriggers',\n\t      value: function flushTriggers() {\n\t        var _this = this;\n\t\n\t        var _loop = function _loop() {\n\t          var waypoints = _this.triggerQueues[direction];\n\t          var reverse = direction === 'up' || direction === 'left';\n\t          waypoints.sort(reverse ? byReverseTriggerPoint : byTriggerPoint);\n\t          waypoints.forEach(function (waypoint) {\n\t            if (waypoint.continuous || i === waypoints.length - 1) {\n\t              waypoint.trigger(direction);\n\t            }\n\t          });\n\t        };\n\t\n\t        for (var direction in this.triggerQueues) {\n\t          _loop();\n\t        }\n\t        this.clearTriggerQueues();\n\t      }\n\t    }, {\n\t      key: 'next',\n\t      value: function next(waypoint) {\n\t        this.waypoints.sort(byTriggerPoint);\n\t        var index = this.waypoints.indexOf(waypoint);\n\t        if (index === -1 || index === this.waypoints.length - 1) {\n\t          return null;\n\t        }\n\t        return this.waypoints[index + 1];\n\t      }\n\t    }, {\n\t      key: 'previous',\n\t      value: function previous(waypoint) {\n\t        this.waypoints.sort(byTriggerPoint);\n\t        var index = Waypoint.Adapter.inArray(waypoint, this.waypoints);\n\t        if (index === -1 || !index) {\n\t          return null;\n\t        }\n\t        return this.waypoints[index - 1];\n\t      }\n\t    }, {\n\t      key: 'first',\n\t      value: function first() {\n\t        return this.waypoints[0];\n\t      }\n\t    }, {\n\t      key: 'last',\n\t      value: function last() {\n\t        return this.waypoints[this.waypoints.length - 1];\n\t      }\n\t    }], [{\n\t      key: 'findOrCreate',\n\t      value: function findOrCreate(options) {\n\t        return groups[options.axis][options.name] || new Group(options);\n\t      }\n\t    }]);\n\t\n\t    return Group;\n\t  }();\n\t};\n\n/***/ },\n/* 4 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tmodule.exports = function (DOM, Context, Group) {\n\t  var keyCounter = 0;\n\t  var allWaypoints = {};\n\t  var axialDirections = {\n\t    horizontal: {\n\t      backward: 'left',\n\t      forward: 'right'\n\t    },\n\t    vertical: {\n\t      backward: 'up',\n\t      forward: 'down'\n\t    }\n\t  };\n\t\n\t  return function () {\n\t    function Waypoint(options) {\n\t      _classCallCheck(this, Waypoint);\n\t\n\t      if (!options) {\n\t        throw new Error('No options passed to Waypoint constructor');\n\t      }\n\t      if (!options.element) {\n\t        throw new Error('No element option passed to Waypoint constructor');\n\t      }\n\t      if (!options.handler) {\n\t        throw new Error('No handler option passed to Waypoint constructor');\n\t      }\n\t\n\t      options = this.mergeOptions(options);\n\t      this.key = 'waypoint-' + keyCounter;\n\t      this.element = options.element;\n\t      this.dom = new DOM(options.element);\n\t      this.callback = options.handler;\n\t      this.axis = options.horizontal ? 'horizontal' : 'vertical';\n\t      this.enabled = options.enabled;\n\t      this.continuous = options.continuous;\n\t      this.offset = options.offset;\n\t      this.triggerPoint = null;\n\t      this.group = Group.findOrCreate({\n\t        name: options.group,\n\t        axis: this.axis\n\t      });\n\t      this.context = Context.findOrCreateByElement(options.context);\n\t\n\t      this.group.add(this);\n\t      this.context.add(this);\n\t      allWaypoints[this.key] = this;\n\t      keyCounter += 1;\n\t    }\n\t\n\t    _createClass(Waypoint, [{\n\t      key: 'mergeOptions',\n\t      value: function mergeOptions(options) {\n\t        if (Waypoint.offsetAliases[options.offset]) {\n\t          options.offset = Waypoint.offsetAliases[options.offset];\n\t        }\n\t        return _extends({}, Waypoint.defaults, options);\n\t      }\n\t    }, {\n\t      key: 'destroy',\n\t      value: function destroy() {\n\t        this.context.remove(this);\n\t        this.group.remove(this);\n\t        delete allWaypoints[this.key];\n\t      }\n\t    }, {\n\t      key: 'disable',\n\t      value: function disable() {\n\t        this.enabled = false;\n\t        return this;\n\t      }\n\t    }, {\n\t      key: 'enable',\n\t      value: function enable() {\n\t        this.context.refresh();\n\t        this.enabled = true;\n\t        return this;\n\t      }\n\t    }, {\n\t      key: 'next',\n\t      value: function next() {\n\t        return this.group.next(this);\n\t      }\n\t    }, {\n\t      key: 'previous',\n\t      value: function previous() {\n\t        return this.group.previous(this);\n\t      }\n\t    }, {\n\t      key: 'trigger',\n\t      value: function trigger(direction) {\n\t        if (this.enabled) {\n\t          this.callback.call(this, direction);\n\t        }\n\t      }\n\t    }, {\n\t      key: 'shouldScrollTrigger',\n\t      value: function shouldScrollTrigger(oldScroll, newScroll) {\n\t        if (this.triggerPoint === null) {\n\t          return null;\n\t        }\n\t\n\t        var wasBeforeTriggerPoint = oldScroll < this.triggerPoint;\n\t        var nowAfterTriggerPoint = newScroll >= this.triggerPoint;\n\t\n\t        if (wasBeforeTriggerPoint && nowAfterTriggerPoint) {\n\t          return this.axialDirection('forward');\n\t        } else if (!wasBeforeTriggerPoint && !nowAfterTriggerPoint) {\n\t          return this.axialDirection('backward');\n\t        }\n\t      }\n\t    }, {\n\t      key: 'refreshTriggerPoint',\n\t      value: function refreshTriggerPoint(_ref) {\n\t        var contextDimension = _ref.contextDimension,\n\t            contextAdjustment = _ref.contextAdjustment;\n\t\n\t        var elementOffset = 0;\n\t        var adjustment = this.offset;\n\t        var oldTriggerPoint = this.triggerPoint;\n\t\n\t        if (!this.dom.isWindow) {\n\t          var offsetProp = this.axis === 'vertical' ? 'top' : 'left';\n\t          elementOffset = this.dom.offset()[offsetProp];\n\t        }\n\t\n\t        if (typeof this.offset === 'function') {\n\t          adjustment = this.offset.apply(this);\n\t        } else if (typeof this.offset === 'string') {\n\t          adjustment = parseFloat(adjustment);\n\t          if (this.offset.indexOf('%') > -1) {\n\t            adjustment = Math.ceil(contextDimension * adjustment / 100);\n\t          }\n\t        }\n\t\n\t        this.triggerPoint = Math.floor(elementOffset + contextAdjustment - adjustment);\n\t        return this.shouldRefreshTrigger(oldTriggerPoint);\n\t      }\n\t    }, {\n\t      key: 'shouldRefreshTrigger',\n\t      value: function shouldRefreshTrigger(oldTriggerPoint) {\n\t        var scrollProp = this.axis === 'vertical' ? 'y' : 'x';\n\t        var contextScroll = this.context.oldScroll[scrollProp];\n\t        var wasBeforeScroll = oldTriggerPoint < contextScroll;\n\t        var nowAfterScroll = this.triggerPoint >= contextScroll;\n\t        var triggeredBackward = wasBeforeScroll && nowAfterScroll;\n\t        var triggeredForward = !wasBeforeScroll && !nowAfterScroll;\n\t        var freshWaypoint = oldTriggerPoint === null;\n\t\n\t        if (!freshWaypoint && triggeredBackward) {\n\t          return this.axialDirection('backward');\n\t        } else if (!freshWaypoint && triggeredForward) {\n\t          return this.axialDirection('forward');\n\t        } else if (freshWaypoint && contextScroll >= this.triggerPoint) {\n\t          return this.axialDirection('forward');\n\t        }\n\t      }\n\t    }, {\n\t      key: 'axialDirection',\n\t      value: function axialDirection(direction) {\n\t        return axialDirections[this.axis][direction];\n\t      }\n\t    }], [{\n\t      key: 'invokeAll',\n\t      value: function invokeAll(method) {\n\t        for (var waypointKey in allWaypoints) {\n\t          allWaypoints[waypointKey][method]();\n\t        }\n\t      }\n\t    }, {\n\t      key: 'destroyAll',\n\t      value: function destroyAll() {\n\t        this.invokeAll('destroy');\n\t      }\n\t    }, {\n\t      key: 'disableAll',\n\t      value: function disableAll() {\n\t        this.invokeAll('disable');\n\t      }\n\t    }, {\n\t      key: 'enableAll',\n\t      value: function enableAll() {\n\t        Context.refreshAll();\n\t        for (var waypointKey in allWaypoints) {\n\t          allWaypoints[waypointKey].enabled = true;\n\t        }\n\t      }\n\t    }, {\n\t      key: 'refreshAll',\n\t      value: function refreshAll() {\n\t        Context.refreshAll();\n\t      }\n\t    }, {\n\t      key: 'viewportHeight',\n\t      value: function viewportHeight() {\n\t        return new DOM(window).innerHeight();\n\t      }\n\t    }, {\n\t      key: 'viewportWidth',\n\t      value: function viewportWidth() {\n\t        return new DOM(window).innerWidth();\n\t      }\n\t    }, {\n\t      key: 'offsetAliases',\n\t      get: function get() {\n\t        return {\n\t          'bottom-in-view': function bottomInView() {\n\t            return this.context.dom.innerHeight() - this.dom.outerHeight();\n\t          },\n\t          'right-in-view': function rightInView() {\n\t            return this.context.dom.innerWidth() - this.dom.outerWidth();\n\t          }\n\t        };\n\t      }\n\t    }, {\n\t      key: 'defaults',\n\t      get: function get() {\n\t        return {\n\t          context: window,\n\t          continuous: true,\n\t          enabled: true,\n\t          group: 'default',\n\t          horizontal: false,\n\t          offset: 0\n\t        };\n\t      }\n\t    }]);\n\t\n\t    return Waypoint;\n\t  }();\n\t};\n\n/***/ }\n/******/ ]);\n\n\n// WEBPACK FOOTER //\n// waypoints.min.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap a5ac1ede704baa28b3ff","var DOM = require('./dom')\nvar Context = require('./context')(DOM)\nvar Group = require('./group')()\nvar Waypoint = require('./waypoint')(DOM, Context, Group)\nvar oldWindowLoad = window.onload\n\nContext.findOrCreateByElement(window)\n\nwindow.onload = function () {\n  if (oldWindowLoad) {\n    oldWindowLoad()\n  }\n  Context.refreshAll()\n}\n\nwindow.Waypoint = Waypoint\nmodule.exports = Waypoint\n\n\n\n// WEBPACK FOOTER //\n// ./source/index.js","module.exports = class DOM {\n  constructor (element) {\n    this.element = element\n    this.handlers = {}\n    this.isWindow = element.window === element\n    this.window = this.isWindow ? element : element.ownerDocument.defaultView\n  }\n\n  innerHeight () {\n    if (this.isWindow) {\n      return this.innerHeight || this.docElement.clientHeight\n    }\n    return this.element.clientHeight\n  }\n\n  innerWidth () {\n    if (this.isWindow) {\n      return this.innerWidth\n    }\n    return this.element.clientWidth\n  }\n\n  outerHeight (includeMargin) {\n    var height = this.innerHeight()\n\n    if (includeMargin && !this.isWindow) {\n      let computedStyle = window.getComputedStyle(this.element)\n      height += parseInt(computedStyle.marginTop, 10)\n      height += parseInt(computedStyle.marginBottom, 10)\n    }\n\n    return height\n  }\n\n  outerWidth (includeMargin) {\n    var width = this.innerWidth()\n\n    if (includeMargin && !this.isWindow) {\n      let computedStyle = window.getComputedStyle(this.element)\n      width += parseInt(computedStyle.marginLeft, 10)\n      width += parseInt(computedStyle.marginRight, 10)\n    }\n\n    return width\n  }\n\n  scrollLeft () {\n    return this.element[this.isWindow ? 'pageXOffset' : 'scrollLeft']\n  }\n\n  scrollTop () {\n    return this.element[this.isWindow ? 'pageYOffset' : 'scrollTop']\n  }\n\n  on (event, handler) {\n    const [eventType, namespace='__default'] = event.split('.')\n    const nsHandlers = this.handlers[namespace] = this.handlers[namespace] || {}\n    const nsTypeList = nsHandlers[eventType] = nsHandlers[eventType] || []\n\n    nsTypeList.push(handler)\n    this.element.addEventListener(eventType, handler)\n  }\n\n  off (event, handler) {\n    const [eventType, namespace] = event.split('.')\n\n    if (namespace && this.handlers[namespace] && eventType) {\n      this.removeListeners(this.handlers[namespace][eventType], handler)\n      this.handlers[namespace][eventType] = []\n    } else if (eventType) {\n      for (var ns in this.handlers) {\n        this.removeListeners(this.handlers[ns][eventType] || [], handler)\n        this.handlers[ns][eventType] = []\n      }\n    } else if (namespace && this.handlers[namespace]) {\n      for (var type in this.handlers[namespace]) {\n        this.removeListeners(this.handlers[namespace][type], handler)\n      }\n      this.handlers[namespace] = {}\n    }\n  }\n\n  removeListeners (listeners, handler) {\n    listeners.forEach((listener) => {\n      if (!handler || handler === listener) {\n        this.element.removeEventListener(listener)\n      }\n    })\n  }\n\n  /* Adapted from jQuery 1.x offset() */\n  offset () {\n    if (!this.element.ownerDocument) {\n      return null\n    }\n\n    const documentElement = this.element.ownerDocument.documentElement\n    const rect = this.element.getBoundingClientRect()\n\n    return {\n      top: rect.top + this.window.pageYOffset - documentElement.clientTop,\n      left: rect.left + this.window.pageXOffset - documentElement.clientLeft\n    }\n  }\n\n  static viewportHeight () {\n    return window.innerHeight || document.documentElement.clientHeight\n  }\n\n  static viewportWidth () {\n    return document.documentElement.clientWidth\n  }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./source/dom.js","function isEmptyObject (obj) {\n  for (var key in obj) {\n    return false\n  }\n  return true\n}\n\nmodule.exports = function (DOM) {\n  var keyCounter = 0\n  var contexts = {}\n  var reqAnimationFrame = (\n    window.requestAnimationFrame ||\n    window.mozRequestAnimationFrame ||\n    window.webkitRequestAnimationFrame ||\n    window.oRequestAnimationFrame ||\n    requestAnimationFrameShim\n  ).bind(window)\n\n  function requestAnimationFrameShim (callback) {\n    window.setTimeout(callback, 1000 / 60)\n  }\n\n  return class Context {\n    constructor (element) {\n      this.element = element\n      this.dom = new DOM(element)\n      this.key = `context-${keyCounter}`\n      this.didScroll = false\n      this.didResize = false\n      this.oldScroll = {\n        x: this.dom.scrollLeft(),\n        y: this.dom.scrollTop()\n      }\n      this.waypoints = {\n        vertical: {},\n        horizontal: {}\n      }\n\n      element.waypointContextKey = this.key\n      contexts[element.waypointContextKey] = this\n      keyCounter += 1\n\n      this.createThrottledScrollHandler()\n      if (this.dom.isWindow) {\n        this.createThrottledResizeHandler()\n      }\n    }\n\n    createThrottledScrollHandler () {\n      const scrollHandler = () => {\n        this.handleScroll()\n        this.didScroll = false\n      }\n\n      this.dom.on('scroll.waypoints', () => {\n        if (!this.didScroll) {\n          this.didScroll = true\n          reqAnimationFrame(scrollHandler)\n        }\n      })\n    }\n\n    createThrottledResizeHandler () {\n      const resizeHandler = () => {\n        this.handleResize()\n        this.didResize = false\n      }\n\n      this.dom.on('resize.waypoints', () => {\n        if (!this.didResize) {\n          this.didResize = true\n          reqAnimationFrame(resizeHandler)\n        }\n      })\n    }\n\n    handleResize () {\n      Context.refreshAll()\n    }\n\n    handleScroll () {\n      var triggeredGroups = {}\n      var axes = {\n        horizontal: {\n          newScroll: this.dom.scrollLeft(),\n          oldScroll: this.oldScroll.x\n        },\n        vertical: {\n          newScroll: this.dom.scrollTop(),\n          oldScroll: this.oldScroll.y\n        }\n      }\n\n      for (var axisKey in axes) {\n        var axis = axes[axisKey]\n\n        for (var waypointKey in this.waypoints[axisKey]) {\n          var waypoint = this.waypoints[axisKey][waypointKey]\n          var direction = waypoint.shouldScrollTrigger(axis.oldScroll, axis.newScroll)\n          if (direction) {\n            waypoint.group.queueTrigger(waypoint, direction)\n            triggeredGroups[waypoint.group.id] = waypoint.group\n          }\n        }\n      }\n\n      for (var groupKey in triggeredGroups) {\n        triggeredGroups[groupKey].flushTriggers()\n      }\n\n      this.oldScroll = {\n        x: axes.horizontal.newScroll,\n        y: axes.vertical.newScroll\n      }\n    }\n\n    add (waypoint) {\n      this.waypoints[waypoint.axis][waypoint.key] = waypoint\n      this.refresh()\n    }\n\n    remove (waypoint) {\n      var horizontalEmpty = isEmptyObject(this.waypoints.horizontal)\n      var verticalEmpty = isEmptyObject(this.waypoints.vertical)\n\n      delete this.waypoints[waypoint.axis][waypoint.key]\n      if (horizontalEmpty && verticalEmpty && !this.dom.isWindow) {\n        this.dom.off('.waypoints')\n        delete contexts[this.key]\n      }\n    }\n\n    destroy () {\n      for (var axis in this.waypoints) {\n        for (var waypointKey in this.waypoints[axis]) {\n          this.waypoints[axis][waypointKey].destroy()\n        }\n      }\n    }\n\n    refresh () {\n      this.handleScroll()\n\n      var contextOffset = this.dom.offset() || { left: 0, top: 0 }\n      var triggeredGroups = {}\n      var axes = {\n        horizontal: {\n          contextOffset: contextOffset.left,\n          contextScroll: this.dom.isWindow ? 0 : this.oldScroll.x,\n          contextDimension: this.dom.innerWidth()\n        },\n        vertical: {\n          contextOffset: contextOffset.top,\n          contextScroll: this.dom.isWindow ? 0 : this.oldScroll.y,\n          contextDimension: this.dom.innerHeight()\n        }\n      }\n\n      for (var axisKey in axes) {\n        var axis = axes[axisKey]\n        for (var waypointKey in this.waypoints[axisKey]) {\n          var waypoint = this.waypoints[axisKey][waypointKey]\n          var direction = waypoint.refreshTriggerPoint({\n            contextDimension: axis.contextDimension,\n            contextAdjustment: axis.contextScroll - axis.contextOffset\n          })\n\n          if (direction) {\n            waypoint.group.queueTrigger(waypoint, direction)\n            triggeredGroups[waypoint.group.id] = waypoint.group\n          }\n        }\n      }\n\n      reqAnimationFrame(function() {\n        for (var groupKey in triggeredGroups) {\n          triggeredGroups[groupKey].flushTriggers()\n        }\n      })\n\n      return this\n    }\n\n    static findOrCreateByElement (element) {\n      return Context.findByElement(element) || new Context(element)\n    }\n\n    static findByElement (element) {\n      return contexts[element.waypointContextKey]\n    }\n\n    static refreshAll () {\n      for (var contextId in contexts) {\n        contexts[contextId].refresh()\n      }\n    }\n  }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./source/context.js","module.exports = function () {\n  function byTriggerPoint (a, b) {\n    return a.triggerPoint - b.triggerPoint\n  }\n\n  function byReverseTriggerPoint(a, b) {\n    return b.triggerPoint - a.triggerPoint\n  }\n\n  var groups = {\n    vertical: {},\n    horizontal: {}\n  }\n\n  return class Group {\n    constructor ({ axis, name }) {\n      this.name = name\n      this.axis = axis\n      this.id = `${name}-${axis}`\n      this.waypoints = []\n      this.clearTriggerQueues()\n      groups[axis][name] = this\n    }\n\n    add (waypoint) {\n      this.waypoints.push(waypoint)\n    }\n\n    remove (waypoint) {\n      var index = this.waypoints.indexOf(waypoint)\n      if (index > -1) {\n        this.waypoints.splice(index, 1)\n      }\n    }\n\n    clearTriggerQueues () {\n      this.triggerQueues = {\n        up: [],\n        down: [],\n        left: [],\n        right: []\n      }\n    }\n\n    queueTrigger (waypoint, direction) {\n      this.triggerQueues[direction].push(waypoint)\n    }\n\n    flushTriggers () {\n      for (var direction in this.triggerQueues) {\n        let waypoints = this.triggerQueues[direction]\n        let reverse = direction === 'up' || direction === 'left'\n        waypoints.sort(reverse ? byReverseTriggerPoint : byTriggerPoint)\n        waypoints.forEach(function (waypoint) {\n          if (waypoint.continuous || i === waypoints.length - 1) {\n            waypoint.trigger(direction)\n          }\n        })\n      }\n      this.clearTriggerQueues()\n    }\n\n    next (waypoint) {\n      this.waypoints.sort(byTriggerPoint)\n      var index = this.waypoints.indexOf(waypoint)\n      if (index === -1 || index === this.waypoints.length - 1) {\n        return null\n      }\n      return this.waypoints[index + 1]\n    }\n\n    previous (waypoint) {\n      this.waypoints.sort(byTriggerPoint)\n      var index = Waypoint.Adapter.inArray(waypoint, this.waypoints)\n      if (index === -1 || !index) {\n        return null\n      }\n      return this.waypoints[index - 1]\n    }\n\n    first () {\n      return this.waypoints[0]\n    }\n\n    last () {\n      return this.waypoints[this.waypoints.length - 1]\n    }\n\n    static findOrCreate (options) {\n      return groups[options.axis][options.name] || new Group(options)\n    }\n  }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./source/group.js","module.exports = function (DOM, Context, Group) {\n  var keyCounter = 0\n  var allWaypoints = {}\n  var axialDirections = {\n    horizontal: {\n      backward: 'left',\n      forward: 'right'\n    },\n    vertical: {\n      backward: 'up',\n      forward: 'down'\n    }\n  }\n\n\n  return class Waypoint {\n    constructor (options) {\n      if (!options) {\n        throw new Error('No options passed to Waypoint constructor')\n      }\n      if (!options.element) {\n        throw new Error('No element option passed to Waypoint constructor')\n      }\n      if (!options.handler) {\n        throw new Error('No handler option passed to Waypoint constructor')\n      }\n\n      options = this.mergeOptions(options)\n      this.key = `waypoint-${keyCounter}`\n      this.element = options.element\n      this.dom = new DOM(options.element)\n      this.callback = options.handler\n      this.axis = options.horizontal ? 'horizontal' : 'vertical'\n      this.enabled = options.enabled\n      this.continuous = options.continuous\n      this.offset = options.offset\n      this.triggerPoint = null\n      this.group = Group.findOrCreate({\n        name: options.group,\n        axis: this.axis\n      })\n      this.context = Context.findOrCreateByElement(options.context)\n\n      this.group.add(this)\n      this.context.add(this)\n      allWaypoints[this.key] = this\n      keyCounter += 1\n    }\n\n    mergeOptions (options) {\n      if (Waypoint.offsetAliases[options.offset]) {\n        options.offset = Waypoint.offsetAliases[options.offset]\n      }\n      return {...Waypoint.defaults, ...options}\n    }\n\n    destroy () {\n      this.context.remove(this)\n      this.group.remove(this)\n      delete allWaypoints[this.key]\n    }\n\n    disable () {\n      this.enabled = false\n      return this\n    }\n\n    enable () {\n      this.context.refresh()\n      this.enabled = true\n      return this\n    }\n\n    next () {\n      return this.group.next(this)\n    }\n\n    previous () {\n      return this.group.previous(this)\n    }\n\n    trigger (direction) {\n      if (this.enabled) {\n        this.callback.call(this, direction)\n      }\n    }\n\n    shouldScrollTrigger (oldScroll, newScroll) {\n      if (this.triggerPoint === null) {\n        return null\n      }\n\n      var wasBeforeTriggerPoint = oldScroll < this.triggerPoint\n      var nowAfterTriggerPoint = newScroll >= this.triggerPoint\n\n      if (wasBeforeTriggerPoint && nowAfterTriggerPoint) {\n        return this.axialDirection('forward')\n      } else if (!wasBeforeTriggerPoint && !nowAfterTriggerPoint) {\n        return this.axialDirection('backward')\n      }\n    }\n\n    refreshTriggerPoint ({ contextDimension, contextAdjustment }) {\n      var elementOffset = 0\n      var adjustment = this.offset\n      var oldTriggerPoint = this.triggerPoint\n\n      if (!this.dom.isWindow) {\n        let offsetProp = this.axis === 'vertical' ? 'top' : 'left'\n        elementOffset = this.dom.offset()[offsetProp]\n      }\n\n      if (typeof this.offset === 'function') {\n        adjustment = this.offset.apply(this)\n      } else if (typeof this.offset === 'string') {\n        adjustment = parseFloat(adjustment)\n        if (this.offset.indexOf('%') > - 1) {\n          adjustment = Math.ceil(contextDimension * adjustment / 100)\n        }\n      }\n\n      this.triggerPoint = Math.floor(elementOffset + contextAdjustment - adjustment)\n      return this.shouldRefreshTrigger(oldTriggerPoint)\n    }\n\n    shouldRefreshTrigger(oldTriggerPoint) {\n      var scrollProp = this.axis === 'vertical' ? 'y' : 'x'\n      var contextScroll = this.context.oldScroll[scrollProp]\n      var wasBeforeScroll = oldTriggerPoint < contextScroll\n      var nowAfterScroll = this.triggerPoint >= contextScroll\n      var triggeredBackward = wasBeforeScroll && nowAfterScroll\n      var triggeredForward = !wasBeforeScroll && !nowAfterScroll\n      var freshWaypoint = oldTriggerPoint === null\n\n      if (!freshWaypoint && triggeredBackward) {\n        return this.axialDirection('backward')\n      } else if (!freshWaypoint && triggeredForward) {\n        return this.axialDirection('forward')\n      } else if (freshWaypoint && contextScroll >= this.triggerPoint) {\n        return this.axialDirection('forward')\n      }\n    }\n\n    axialDirection (direction) {\n      return axialDirections[this.axis][direction]\n    }\n\n    static invokeAll (method) {\n      for (var waypointKey in allWaypoints) {\n        allWaypoints[waypointKey][method]()\n      }\n    }\n\n    static destroyAll () {\n      this.invokeAll('destroy')\n    }\n\n    static disableAll () {\n      this.invokeAll('disable')\n    }\n\n    static enableAll () {\n      Context.refreshAll()\n      for (var waypointKey in allWaypoints) {\n        allWaypoints[waypointKey].enabled = true\n      }\n    }\n\n    static refreshAll () {\n      Context.refreshAll()\n    }\n\n    static viewportHeight () {\n      return (new DOM(window)).innerHeight()\n    }\n\n    static viewportWidth () {\n      return (new DOM(window)).innerWidth()\n    }\n\n\n    static get offsetAliases () {\n      return {\n        'bottom-in-view': function() {\n          return this.context.dom.innerHeight() - this.dom.outerHeight()\n        },\n        'right-in-view': function() {\n          return this.context.dom.innerWidth() - this.dom.outerWidth()\n        }\n      }\n    }\n\n    static get defaults () {\n      return {\n        context: window,\n        continuous: true,\n        enabled: true,\n        group: 'default',\n        horizontal: false,\n        offset: 0\n      }\n    }\n\n    static get offsetAliases () {\n      return {\n        'bottom-in-view': function () {\n          return this.context.dom.innerHeight() - this.dom.outerHeight()\n        },\n        'right-in-view': function () {\n          return this.context.dom.innerWidth() - this.dom.outerWidth()\n        }\n      }\n    }\n  }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./source/waypoint.js"],"sourceRoot":""}